= TinyMCE 6.6.2
:navtitle: TinyMCE 6.6.2
:description: Release notes for TinyMCE 6.6.2
:keywords: releasenotes, new, changes, bugfixes
:page-toclevels: 1

include::partial$misc/admon-releasenotes-for-stable.adoc[]

[[overview]]
== Overview

{productname} 6.6.2 was released for {enterpriseversion} and {cloudname} on Wednesday, August 9^th^, 2023. These release notes provide an overview of the changes for {productname} 6.6.2, including:

* xref:accompanying-premium-plugin-changes[Accompanying Premium plugin changes]
* xref:accompanying-premium-skins-and-icon-packs-changes[Accompanying Premium Skins and Icon Packs changes]
* xref:improvement[Improvement]
* xref:addition[Addition]
* xref:change[Change]
* xref:bug-fixes[Bug fixes]



[[accompanying-premium-plugin-changes]]
== Accompanying Premium plugin changes

The following premium plugin updates were released alongside {productname} 6.6.2.

=== AI Assistant 1.0.1

The {productname} 6.6.2 release includes an accompanying release of the **AI Assistant** premium plugin.

**AI Assistant** 1.0.1 includes the following fixes:

==== Toolbar buttons and menu items were enabled while the dialog was waiting for a final response
//#TINY-10077 #1

The **AI Assistant** toolbar buttons and menu items provide no functionality while a response is being generated in the AI Assistant dialog. Previously, however, these buttons and items continued to present as enabled during response generation.

With the release of **AI Assistant** 1.0.1, this has been corrected. The plugin’s toolbar buttons and menu items are now disabled while a response is being generated.

==== Error events from streaming requests were included in separate threads to the corresponding response event
//#TINY-10077 #2

Previously, when an error occurred while a streaming response was in progress, both an error and response event were added to the current thread.

**AI Assistant 1.0.1** corrects this. Now, when an error occurs during an in-progress streaming response, a single event — containing both the error and the response — is added to the current thread.

==== Preview content was removed when an error is encountered part way through a streaming response
//#TINY-10096

Previously, when an error was encountered while a streaming response was in progress, the **AI Assistant** dialog removed the partial response when displaying the error.

With the release of **AI Assistant 1.0.1**, the partial response is left in place, displayed as a finished response.

And the error message is displayed below this, left-in-place, response.

==== When a response from the AI Assistant dialog was inserted into a selection not in view, the content did not scroll into view
//#TINY-10102

Previously when inserting a response from the AI Assistant dialog at a selection which is above the current view, the inserted content would not be scrolled into view.

In **AI Assistant** 1.0.1, the response is now inserted after the dialog is closed, allowing the content to be scrolled into view correctly.

For information on the **AI Assistant** plugin, see: xref:ai.adoc[AI Assistant].


=== Enhanced Image Editing

The {productname} 6.6.2 release includes an accompanying release of the **Enhanced Image Editing** premium plugin.

**Enhanced Image Editing** 1.1.1 includes the following fix:

==== Context menu and context toolbar no longer show when the selected image is in a non-editable context
//#TINY-10016

When a {productname} instance is setup with `editable_root: false` set, the entire instance is, by default, a read-only instance.

To allow editing of any portion, that portion must be specifically set as writable (for example, by being within an element that has a `contenteditable="true"` attribute set).

Previously, however, if an image was in a {productname} instance with both an `editable_root: false` set and the xref:editimage.adoc[Enhanced Image Editing] Premium plugin loaded, bringing up a {productname} context menu (eg by right-clicking on the image in a desktop setting or by long-pressing on the image in a mobile setting) allowed the Enhanced Image Editing plugin’s context toolbar to present, which allowed for image manipulation.

**Enhanced Image Editing** 1.1.1 addresses this. With this update, invoking a context menu in non-editable area no longer brings up the plugin’s context toolbar.

As a consequence, images presented within a {productname} instance setup with a `editable_root: false` set are properly read-only, as expected.

NOTE: right-clicking on an image, or long-pressing on an image in a mobile instance, still invokes the host browser’s context menu in such a circumstance.

For information on the **Enhanced Image Editing** plugin, see: xref:editimage.adoc[Enhanced Image Editing].



[[accompanying-premium-skins-and-icon-packs-changes]]
== Accompanying Premium Skins and Icon Packs changes

The {productname} 6.6.2 release includes an accompanying release of the **Premium Skins and Icon Packs**.

=== Premium Skins and Icon Packs

The **Premium Skins and Icon Packs** release includes the following updates:

The **Premium Skins and Icon Packs** were rebuilt to pull in the changes also incorporated into the default {productname} 6.6.2 skin, Oxide.

For information on using premium skins and icon packs, see: xref:premium-skins-and-icons.adoc[Premium Skins and Icon Packs].



[[improvement]]
== Improvement

{productname} 6.6.2 also includes the following improvement:

=== When Safari is the host browser, content updates for iframe dialog components with `streamContent: true` set are now throttled to 500ms intervals
//#TINY-10097

When `iframe` dialog components have xref:dialog-configuration.adoc#dialog_streamContent[`streamContent: true`] set, content is updated using the `document.write()` method rather than by setting the `srcdoc` attribute to prevent the `iframe` from reloading.

This setting stops the iframe from flickering as it updates its contents when the host browser is Google Chrome or Mozilla Firefox.

The flickering still occurred when the host browser was Apple Safari, however.

In {productname} 6.6.2, content updates for `iframe` dialog components with `streamContent: true` set are throttled to 500ms intervals when Safari is the host browser. This significantly reduces the apparent flickering.

NOTE: This 500ms throttling is specific to Safari. It is not applied when any browser other than Safari is the host browser.



[[addition]]
== Addition

{productname} 6.6.2 also includes the following addition:

=== Restored filtering option: `pad_empty_with_br`
//#TINY-9861

{productname} 6.6.2 restores a further content filtering option, `pad_empty_with_br`.

Content filtering options change the way {productname} manages input and output.

The `pad_empty_with_br` option, when set to `true`, places a `+<br>+` tag within empty block elements rather than the default non-breaking space entity, `+&nbsp;+`.

That is, when a {productname} instance includes the following setting

[source,js]
----
pad_empty_with_br: true,
----
 
empty block elements within said instance

[source,html]
----
<p></p>
----

are automatically stored and rendered as

[source,html]
----
<p><br></p>
----

[NOTE]
====
An equivalent filtering option, `padd_empty_with_br` was xref:migration-from-5x.adoc#previously-deprecated-items-now-removed[removed from {productname} 6.0.0].

This new — and correctly spelled — option behaves in essentially identical fashion to the older option.
====



[[change]]
== Change

{productname} 6.6.2 also includes the following change:

=== API comments/documentation: a markup typo and run-on sentences both corrected
//#TINY-10073

A markup typo in `/tinymce/modules/tinymce/src/core/main/ts/api/WindowManager.ts` resulted in an extraneous html markup tag displaying in the xref:/apis/tinymce.windowmanager.adoc[tinymce.WindowManager()] documentation.

As well, two run-on sentences in the same file were corrected.



[[bug-fixes]]
== Bug fixes

{productname} 6.6.2 also includes the following bug fixes:

=== On Safari and Firefox, scroll positions were not always maintained when updating the content of a `streamContent: true` iframe dialog component
//#TINY-10078

On each content update for iframe dialog components with `streamContent: true` set, the iframe is expected to automatically scroll to the bottom if the pre-update scrolled position is already at the end of the scrollable area. It is also expected, however, that the end-user can freely scroll through the iframe as content updates occur.

When Chrome is the host browser, scroll positions are natively maintained after content updates via `document.write()`, but this is not the case when either Safari or Firefox are the host browsers. Both these browsers reset the scroll positions to the top.

As a consequence, once the user scrolls up in the iframe as content updates occur and the programmatic scrolling to the bottom no longer occurs, the native behavior takes over. On Safari and Firefox, this results in the scroll being kept at the top even as the user attempts to scroll, which is both against expected behavior and poor UX.


As of {productname} 6.6.2, after a content update to a `streamContent: true` iframe dialog component, if the host browser is Firefox or Safari and the previous scroll position was not at the end of the scrollable area, {productname} now programmatically restores the previous scroll position.


=== On Safari, iframe dialog components did not consistently autoscroll to the end of the scrollable area when `streamContent: true` was set
//#TINY-10109

{productname} 6.6.0 added support for a `streamContent` setting for iframe dialog components. One of the features of this setting allows the iframe to automatically scroll to the end of the scrollable area on each content update if the scrolled position is already at the end of this area before content updates begin.

However, when Safari was the host browser, when attempting to scroll an iframe component with `streamContent: true` set before its `load` event has fired, the scroll unexpectedly jumped back to the top after the iframe loaded.

This made the autoscrolling feature inconsistent on Safari, as it depended on how quickly the iframe loaded after the content update.

In {productname} 6.6.2, when Safari is the host browser, the autoscrolling behavior is attached to a one-time event listener that responds to the iframe’s `load` event on each content update.

This allows iframe dialog components with `streamContent: true` set to consistently autoscroll to the end of the scrollable area when Safari is the host browser.


=== Scrolling behavior was inconsistent when updating a `streamContent: true` iframe dialog component with content lacking an HTML document type declaration
//#TINY-10110

When an iframe dialog has `streamContent: true` set and the scrolled position is already at the end of the scrollable area, the expected behavior is to maintain this end-of-scrollable-area position by automatically scrolling to the end of the area as content in the scrollable area updates

However, it was found that, when setting content without an HTML document type declaration using `document.write()`, the scrolling element used to determine scrolling conditions is the iframe’s body, not its document element. And, previously, only the latter was handled. As a consequence, updating the iframe with content without an HTML doctype declaration did not always maintain scroll positions as expected.

{productname} 6.6.2 now checks whether the content contains an HTML doctype declaration and, if so, it chooses the iframe’s body as the scrolling element to determine scrolling conditions. This allows content updates for `streamContent: true` iframe dialog components to behave as expected for both content with and without an HTML doctype declaration.


=== A warning message was sometimes printed to the browser console when closing a dialog that contained an iframe component
//#TINY-10070

In some circumstances, when a dialog that contained an iframe component was closed, the console warning message, *the component must be in a context to execute*, was generated.

This happened because, while the dialog was closed, the currently focussed element was not within the {productname} instance. This caused the `onAction()` callback function to set the focus back to the (now closed) dialog element.

In {productname} 6.6.2, a check has been implemented:

* to see if the dialog still exists within the DOM; and
* to ensure the element with focus is within the {productname} instance after a dialog is closed.

As a consequence, the console warning is no longer generated when dialogs with iframe components are closed.


=== Lists could not be created within editable areas nested inside non-editable areas
//#TINY-10000

{productname} 6.5 introduced a check to establish if the current node was within a non-editable context.

As a consequence of this check, if an editable element was nested in a non-editable element, adding a list within the editable element did not work as expected.

Other expected edits — such as changing the selected material’s block element type from paragraph to a heading — worked as expected. It was only adding a list, or making existing material into a list, that did not work as expected.

In {productname} 6.6.2, this check has been removed. Adding or making lists within editable elements now works in all expected contexts, including when the editable element is within a non-editable element.


=== On Safari and Firefox, the border around `iframe` dialog components did not highlight when focused
//TINY-10101

{productname} 6.6, introduced a new dialog configuration property, xref:dialog-configuration.adoc#border[`border`].

When set to `true`, this property adds a border around `iframe` dialog components that highlights when the component takes focus. By default, {productname} renders this as a blue border around the component.

When either Safari or Firefox were the host browsers, however, the border did not render as expected when this component had focus.

{productname} 6.6.2 corrects this. When either Safari or Firefox are the host browsers, `iframe` dialog components now highlight when taking focus, as expected.


=== Right-clicking on an image that was in a non-editable area would open the Image plugin’s context menu
//#TINY-10016

When a {productname} instance is setup with `editable_root: false` set, the entire instance is, by default, a read-only instance.

To allow editing of any portion, that portion must be specifically set as writable (for example, by being within an element that has a `contenteditable="true"` attribute set).

Previously, however, if an image was in a {productname} instance with both an `editable_root: false` set and the xref:image.adoc[Image open source plugin] loaded, bringing up a {productname} context menu (eg by right-clicking on the image in a desktop setting or by long-pressing on the image in a mobile setting) allowed the Image plugin’s context menu to present, which allowed for image manipulation.

{productname} 6.6.2 addresses this. With this update, invoking a context menu in non-editable area no longer brings up any {productname}-related context menus.

As a consequence, images presented within a {productname} instance setup with a `editable_root: false` set are properly read-only, as expected.

NOTE: right-clicking on an image, or long-pressing on an image in a mobile instance, still invokes the host browser’s context menu in such a circumstance.


=== The `color_cols` option was not respected when a custom `color_map` was defined
// #TINY-10098

The xref:user-formatting-options.adoc#color_cols[`color_cols`] option allows for specifying the number of columns for text color selection grids.

If `color_cols` is not set, the number of columns displayed by a custom color swatch is, by default, the greater of the square root of the number of colors in the swatch and five (5).

The square root is rounded up and five is the default number of columns a {productname} color swatch displays with the default `color_map`.

For example, for a custom xref:user-formatting-options.adoc#color_map[`color_map`] containing 30 colors:

√30 ≅ 5.4772 ≈ 6.

And, since 6 > 5, this custom color selection grid displays six columns.

Setting a `color_cols` value over-rides this default behavior.

Previously, however, the `color_cols` option was not respected when a custom xref:user-formatting-options.adoc#color_map[`color_map`] was specified. In this circumstance the default method above still specified the number of columns displayed.

{productname} 6.6.2 addresses this. As of this update, setting a `color_cols` value over-rides the default method of calculating the number of displayed columns, as expected.

[NOTE]
.Known issue
====
Setting `color_cols: 5` still results in the `color_cols` value not being used.

When `color_cols` is set to the default number of columns displayed by a {productname} color selection grid (ie 5), the default method for calculating the number of displayed columns is used.
====


=== The `color_cols` options were were not rounded to the nearest number when set to a decimal number
//#TINY-9737

Previously, if `color_cols` was set to a value which included a decimal, the resultant text color selection grid displayed incorrectly.

{productname} 6.6.2 addresses this. As of this update, if `color_cols` is set to a decimal value, {productname} rounds the set value to the nearest integer and displays the color selection grid with that many columns.

In this case, {productname} rounds using the *rounding half up* method.

Values **x.1–x.4** are rounded to **x**.

Values **x.5–x.9** are rounded to **x+1**.

NOTE: If `color_cols` is set to a decimal value that would, after rounding, be an invalid value (for example, **0.1**), {productname} continues to act as it did previously. For invalid values, the `color_cols` option is treated as if it has not been set and reverts to displaying the color selection grid with the default five columns.


=== An "Uncaught TypeError: Cannot read properties of null" error would sometimes be thrown when updating the content of a `streamContent: true` iframe dialog component
//TINY-10128

During rapid, intermittent, content updates in an iframe dialog component with `streamContent: true` set, an error — "Uncaught TypeError: Cannot read properties of null" — would sometimes be thrown.

This caused an error when trying to scroll to the bottom of the iframe component.

In {productname} 6.6.2 two changes were made: using a numerical value for `Window.scrollTo` rather than setting it to `body.scrollHeight`; and waiting for `load` before attempting to scroll.

As a consequence the `null` errors are no longer thrown, and scrolling to the bottom of an iframe component works as expected.

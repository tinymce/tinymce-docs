---
layout: default
title: RTC configuration
title_nav: Configuration options
description: List of all available RTC configuration options.
keywords: rtc configuration
---

## List of all available RTC configuration options

> **Note**: These configuration options is subject to change based on customer feedback.

### `rtc_service_url`

The service url should point to the cloud service and include your api key.

**Type:** `String`

**Required:** yes
#### Example setting the service url

```js
tinymce.init({
  ...
  rtc_service_url: 'https://rtc.tiny.cloud/1/<your api key>'
})
```

### `rtc_document_details_provider`

The document details includes a document ID. This is the ID you share with other people collaborating on the document so it should be publicly available.

**Type:** `Function`

**Required:** yes

#### Return fields

* documentId:string - Unique identifier for the document. In a content management system, this could be the resource identifier for the document.

#### Example Using the document details provider to return static document details

```js
tinymce.init({
  ...
  rtc_document_details_provider: () => {
    return Promise.resolve({ documentId: "your-document-id" })
  }
})
```

#### Example Using the document details provider to return document details from your server

```js
tinymce.init({
  ...
  rtc_document_details_provider: () => {
    return fetch('http://yourserver/getDocumentId', {
      method: 'POST'
    })
    .then(documentId => ({ documentId });
  }
})
```

### `rtc_encryption_provider`

The Tiny RTC plugin uses end-to-end encryption and therefore a key needs to be generated to encrypt the messages. This key is never sent to the server so there is no way for the {{site.productname}} RTC service to read your contents since it's encrypted/decrypted in the browser using this shared encryption key. 

Generate a unique key by creating a function that takes the document ID, session ID and, if this is an existing session, a key hint. How you generate the key is up to you. Secure ways include:

* Generate and store a random key for each new document session in your database.
* Generate single random key per document, and salt it *on your server* with the session ID to provide a different key per session.
* Store a global list of keys for your application, and use the document ID and session ID to salt the current key *on your server* to produce a key unique to the document session. You should return a key hint to identify the key in case you rotate to a new key later.

**Type:** `Function`

**Required:** yes

#### Input fields

* documentId:string - Unique public document ID that is used when sharing the document
* sessionId:int - Session ID generated by the server (0 ≤ sessionId < 2³¹)
* keyHint:string/undefined - Key hint (e.g. a key ID) provided by the client which opened the session (only if there is an existing session)

#### Return fields

* key:string - Encryption key that is used to locally encrypt operations this needs to be the same for all connecting clients.
* keyHint:string/undefined - Optional key hint to provide to later clients to aid in key selection. This can be a key thumbprint, ID or other non-sensitive identifier that will help select the key like a timestamp. It is only recorded when opening a new session. (unicode, max 256 characters)

### Example of providing static encryption details

```js
tinymce.init({
  rtc_encryption_provider: ({documentId, sessionId}) => {
    return Promise.resolve({
      key: "your shared encryption key"
    });
  }
})
```

### Example of providing encryption details from your server

```js
tinymce.init({
  rtc_encryption_provider: ({documentId, sessionId, keyHint}) => {
    return fetch('http://yourserver/getKey', {
      method: 'POST',
      body: JSON.stringify({ documentId, sessionId, keyId: keyHint })
    })
    .then(({keyId, secret}) => ({ key: secret, keyHint: keyId });
  }
})
```

### `rtc_token_provider`

The RTC plugin and service uses [JWT]({{site.baseurl}}/rtc/jwt-authentication/) to authenticate the user. This token should include a unique user ID and a relative expiration time. This provider function will be called multiple times to refresh the token if it about to expire. So for production use cases it should be a dynamic request that produces a fresh JWT token with a updated `exp` claim.

**Type:** `Function`

**Required:** yes

### Required JWT claims

* sub:string - the unique user ID (i.e. if `sub` is the same for two clients, you should trust them as if they're the same user)
* exp:int - the timestamp when the token expires

#### Return fields

* token:string - A generated JWT token this should be signed with the private key.

### Example of providing a static JWT token

```js
tinymce.init({
  rtc_token_provider: () => Promise.resolve({ token: "your-jwt-token" })
})
```

### Example of providing a JWT token from your server

```js
tinymce.init({
  rtc_token_provider: () => {
    return fetch('http://yourserver/getJwtToken', {
      method: 'POST'
    })
    .then(token => ({ token });
  }
})
```

### `rtc_snapshot`

In an RTC session you normally don't have a save button as the session is constantly being stored. A snapshot callback is available, it will be executed at regular intervals with the serialized editor contents. The content is retrieved though a getContent function this is to lazily create the serialized version of the model since that serialization process could be CPU intensive.

**Type:** `Function`

**Required:** no

### Input fields

* sessionId:int - Session identifier generated by the server (0 ≤ sessionId < 2³¹)
* version:int - 31 bit number (0 ≤ version < 2³¹) with the increasing version number
* getContent():string - Function to execute to get the content for that particular version.

### Example of getting content snapshots

```js
tinymce.init({
  rtc_snapshot: ({sessionId, version, getContent}) => {
    console.log('Current version', version);
    console.log('HTML', getContent());
  }
}
```

### `rtc_initial_content`

By default the initial contents is retrieved from target element that you initialized the editor on but since that content only needs to be retrieved when there is no active RTC session opened this optional provider function can be used instead to provide the initial content. This also works better with the various tinymce [integrations]({{site.baseurl}}/integrations/) that doesn't provide access to the target element directly.

**Type:** `Function`

**Required:** no

### Return fields

- content:string - String containing the HTML to be imported into the editor when there is no active session.

### Example of providing static content

```js
tinymce.init({
  rtc_initial_content: () => Promise.resolve({ content: "<p>Hello world!</p>" })
})
```

### Example of providing dynamic content from the server

```js
tinymce.init({
  rtc_initial_content: () => {
    return fetch('http://yourserver/getContent', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    });
  }
})
```

### `rtc_user_details_provider`

By default the user ID will be displayed as the name for the remote carets. In order to display a proper full name the user ID needs to be resolved into user details that include the full user name. This provider function will be called for each connecting client if this setting is omitted then the user ID will be presented as name for the remote user if you hover the remote carets.

Only `userId` is guaranteed to be authentic as it comes from the JWT. We suggest using `userId` to fetch user data from your server to guarantee authenticity.

**Type:** `Function`

**Required:** no

### Input fields

- userId:string - User ID to resolve into user details

### Return fields

- fullName:string - Full name of user for example "John Doe"

### Example of providing static user details

```js
tinymce.init({
  rtc_user_details_provider: ({userId}) => Promise.resolve({ fullName: "John Doe" })
})
```

### Example of providing user details from your server

```js
tinymce.init({
  rtc_user_details_provider: ({userId}) => {
    return fetch('http://yourserver/getUserDetails', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({userId})
    });
  }
})
```

### `rtc_custom_user_details`

You might want to provide extra details about the current user to the other connecting clients. This setting enables you to do that. You don't want to pass sensitive information here; the authenticity of user data is not guaranteed.

This API is designed for use in status flags such as "is the user on a mobile device".

An object that must be serializable (`JSON.stringify` will be used to transmit it between clients).

**Type:** `Object`

**Required:** no

### Example of providing custom user details

```js
tinymce.init({
  rtc_custom_user_details: { onMobile: true, region: 'us' }
})
```

### `rtc_user_connected`

In many applications supporting real-time collaboration, the currently connected users are displayed. This setting enables you to track when a user enters the session. There are 8 distinct caret colors so the caret number will be a value from 1-8 if more than 8 people connect numbers will be reused.

**Type:** `Function`

**Required:** no

### Input fields

* userId:string - This is the JWT user ID for the connecting or disconnecting user
* caretNumber:int - The user's caret number 1-8 (helpful to disambiguate when a user connects multiple times)
* custom:object - Custom data passed out from the other clients `rtc_custom_user_details` function. If none is provided this will be an empty object.

### Example of providing custom user details

```js
tinymce.init({
  rtc_user_connected: ({userId, caretNumber, custom}) => {
    console.log('Connected', userId, caretNumber, custom);
  }
})
```

### `rtc_user_disconnected`

In many applications supporting real-time collaboration, the currently connected users are displayed. This setting enables you to track when a user leaves the session.

**Type:** `Function`

**Required:** no

### Input fields for `rtc_user_disconnected`

- userId:string - This is the unique user ID of the disconnecting user
- caretNumber:int - The user's caret number 1-8 (helpful to disambiguate when a user connects multiple times)
* custom:object - Custom data passed out from the other clients `rtc_custom_user_details` function. If none is provided this will be an empty object.

### Example of providing custom user details

```js
tinymce.init({
  rtc_user_disconnected: ({userId, caretNumber, custom}) => console.log('Disconnected', userId, caretNumber);
})
```
